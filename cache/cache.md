# 缓存问题

## 一致性
> 业务在引入分布式系统后, 对数据的更新除了要更新存储以外还需要同时更新缓存, 就需要解决系统的 原子性和隔离性 问题
> ,引入缓存的目的是提升性能, 所以大多数情况下都会选择 牺牲一部分小概率的一致性, 而保证整体的性能
### 解决方案
+ 数据可靠性     优先更新存储,再更新缓存
+ 操作隔离性     保证存储和缓存操作的有序性
+ 操作原子性     保证存储和缓存更新 两者同时成功或同时失败

+  业务层缓存更新方案 【更新存储 -> 删除缓存】 等待下一次读Miss再进行缓存 

### 外部组件更新缓存
> 先更新存储, 再由第三方组件(消息队列等)更新缓存
+ 需要确保 单条数据 更新操作的串行化
+ 需要监控存储日志 , 或通过Triger来监控存储数据变更.
+ 需要对更新进行过滤, 缓存的目标是缓存热数据, 但是像DDL, 批量更新等可能操作冷数据,以及非业务更新操作过滤掉.
+ 同步组件需要单独对数据进行处理, 无法做到通用化.


## 缓存击穿
> - 空数据查询 :大量请求,请求不存在的数据,缓存中不存在, db中也不存在(大量空数据查询<黑客攻击>), 导致请求透传到db, 使DB过载
> - 缓存污染:  在遍历数据等情况下冷数据把热数据驱逐出内存，导致缓存了大量冷数据而热数据被驱逐(一般由爬虫请求导致)
### 解决方案
+ (空数据查询) 通过bloomfilter记录key是否存在，从而避免无效Key的查询 (推荐)
+ (空数据查询) 缓存不存在的Key，从而避免无效Key的查询
+ 缓存污染暂时没有更好的办法, 可通过制定如 10分钟 访问该数据 3次则进行缓存 的缓存规则进行规避

## 缓存雪崩
> 热点数据同一时刻过期, 导致大量请求同时穿透到 db
### 解决方案
+ 主要是通过对key的过期时间加随机数,打散key的淘汰时间来尽量规避,但是不能彻底规避.
+ 每次对数据的访问 都可延长其 key 的 部分过期时间,达到热数据持久保持在缓存中的目的


